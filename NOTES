==Vew action==
    New class in actionList.js based on action type (Order in list is order it will appear in game)
    Add svg to img folder
    Add data in game.xml
    Most stuff is automatically generated and saved by town.js. Any extra data that needs persistance should either
        be a new resource or a variable added to saving.js that is called in the save and load functions and reset
        in actions.js restart()

==New Skill==
    New divs in index.html
    add to skill list in saving.js
    add to getSkillBonus() in stats.js if the skill uses the increase or reduce formulas
    add description in game.xml
    add code to update skill values in main.view.js

==New Buff==
    Add name translation in buffs.view.js
    Add to buff list and buff caps in saving.js
    Add to buffs section in game.xml files

==New Resource==
    Add to resources list in saving.js
    Add resource section of game.xml files
    Resources are automatically reset on new loops by the game code

==New Trial==

    Increase the length of trials[] at the end of index.hmtl
    Add the number of floors to trialfloors in saving.js
    Create a new action in the action list based on the template below
    Other general new action stuff

Action.Trial = new TrialAction("TrialName", trialNum, {
    type: "multipart",
    expMult: 0,
    townNum: townNum,
    stats: {
        Dex: 0.11,
        Str: 0.11,
        Con: 0.11,
        Spd: 0.11,
        Per: 0.11,
        Cha: 0.11,
        Int: 0.11,
        Luck: 0.11,
        Soul: 0.11
    },
    loopStats: ["Dex", "Str", "Con", "Spd", "Per", "Cha", "Int", "Luck", "Soul"],
    affectedBy: ["Team"],
    floorScaling: 1.5, //Difficulty is raised to this exponent each floor
    baseScaling: 1e10, //Difficulty is multiplied by this number each floor
    manaCost() {
        return 100000;
    },
    baseProgress() {
        //Determines what skills give progress to the trial
        return getTeamCombat();
    },
    floorReward() {
        //Rewards given per floor
    },
    canStart() {
        const curFloor = Math.floor((towns[this.townNum][`${this.varName}LoopCounter`]) / this.segments + 0.0000001);
        return curFloor < trialFloors[this.trialNum];
    },
    loopCost(segment) {
        return precision3(Math.pow(this.floorScaling, Math.floor((towns[this.townNum][`${this.varName}LoopCounter`] + segment) / this.segments + 0.0000001)) * this.baseScaling);
    },
    tickProgress(offset) {
        const floor = Math.floor((towns[this.townNum][`${this.varName}LoopCounter`]) / this.segments + 0.0000001);
        return this.baseProgress() *
            (1 + getLevel(this.loopStats[(towns[this.townNum][`${this.varName}LoopCounter`] + offset) % this.loopStats.length]) / 100) *
            Math.sqrt(1 + trials[this.trialNum][floor].completed / 200);
    },
    loopsFinished() {
        const curFloor = Math.floor((towns[this.townNum][`${this.varName}LoopCounter`]) / this.segments + 0.0000001 - 1);
        trials[this.trialNum][curFloor].completed++;
        if (curFloor + 1 > trials[this.trialNum].highestFloor || trials[this.trialNum].highestFloor === undefined) trials[this.trialNum].highestFloor = curFloor + 1;
        view.updateTrialInfo(this.trialNum, curFloor + 1);
        this.floorReward();
    },
    visible() {
        return true;
    },
    unlocked() {
        return true;
    },
    finish() {
    },
});